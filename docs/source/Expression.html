<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='MEPH-math-Expression'>/**
</span> * @class MEPH.math.Expression
 * Describes mathematical expressions.
 *
 **/
MEPH.define(&#39;MEPH.math.Expression&#39;, {
    alternateNames: &#39;Expression&#39;,
    requires: [&#39;MEPH.math.ExpressionMatch&#39;,
                &#39;MEPH.math.ExpressionTranslation&#39;],
    statics: {
        type: {
            variable: &#39;variable&#39;,
            integral: &#39;integral&#39;,
            addition: &#39;addition&#39;,
            power: &#39;power&#39;,
            limit: &#39;limit&#39;,
            fraction: &#39;fraction&#39;,
            sin: &#39;sin&#39;,
            cos: &#39;cos&#39;,
            tan: &#39;tan&#39;,
            csc: &#39;csc&#39;,
            cot: &#39;cot&#39;,
            sec: &#39;sec&#39;,
            tan: &#39;tan&#39;,
            ln: &#39;ln&#39;,
            negative: &#39;negative&#39;,
            abs: &#39;abs&#39;,
            func: &#39;func&#39;,
            mod: &#39;mod&#39;,
            modulo: &#39;modulo&#39;,
            theta: &#39;theta&#39;,
            subtraction: &#39;subtraction&#39;,
            plusminus: &#39;plusminus&#39;,
            multiplication: &#39;multiplication&#39;,
            division: &#39;division&#39;,
            anything: &#39;anything&#39;,
            dirivitive: &#39;dirivitive&#39;
        },

        &#39;function&#39;: {
            input: &#39;input&#39;,
            start: &#39;start&#39;,
            end: &#39;end&#39;,
            name: &#39;name&#39;,
            denominator: &#39;denominator&#39;,
            numerator: &#39;numerator&#39;,
            base: &#39;base&#39;,
            expression: &#39;exp&#39;,
            power: &#39;power&#39;,
            respectTo: &#39;respectTo&#39;,
            dirivitive: &#39;dirivitive&#39;
        },
        translation: {
            Translate: function (a, b) {
                return ExpressionTranslation.translate(a, b)
            },
            Transform: function (transform, a, b) {
                return ExpressionTranslation.transform(transform, a, b);
            }
        },
        RuleType: {
            IntegralConstMultiply: &#39;IntegralConstMultiply&#39;,
            MultiplyIntegralofFx: &#39;MultiplyIntegralofFx&#39;,
            IntegralConst: &#39;IntegralConst&#39;,
            AxPlusC: &#39;AxPlusC&#39;,
            Power: &#39;Power&#39;,
            PowerIntegrate: &#39;PowerIntegrate&#39;,
            IntegrationAddition: &#39;IntegrationAddition&#39;,
            AdditionIntegral: &#39;AdditionIntegral&#39;,
            IntegrationByParts: &#39;IntegrationByParts&#39;,
            IntegrationByPartsComplete: &#39;IntegrationByPartsComplete&#39;,
            Fudx: &#39;Fudx&#39;,
            FuOveruprimedx: &#39;FuOveruprimedx&#39;,
            OneOverX: &#39;OneOverX&#39;,
            NaturalLogAbsX: &#39;NaturalLogAbsX&#39;,
            GeneralFormula8A: &#39;GeneralFormula8A&#39;,
            GeneralFormula8B: &#39;GeneralFormula8B&#39;,
            GeneralFormula9A: &#39;GeneralFormula9A&#39;,
            GeneralFormula9B: &#39;GeneralFormula9B&#39;,
            TrigonometricFormula10A: &#39;TrigonometricFormula10A&#39;,
            TrigonometricFormula10B: &#39;TrigonometricFormula10B&#39;,
            TrigonometricFormula11A: &#39;TrigonometricFormula11A&#39;,
            TrigonometricFormula11B: &#39;TrigonometricFormula11B&#39;
        },
        Dependency: {
            ConstRelation: function (c, x) {
                var inRespectTo = x &amp;&amp; x.val &amp;&amp; x.val.part ? x.val.part(&#39;variable&#39;).val : x.val;
                return !c.respects().contains(function (x) { return x === inRespectTo; });
            }
        },
        Rules: {
            IntegralConstMultiply: function () {
                var c = Expression.variable(&#39;A&#39;);
                c.mark(&#39;C&#39;);
                var a = Expression.anything();
                a.mark(&#39;A&#39;);
                var expression = Expression.integral(Expression.multiplication(c, a), &#39;x&#39;);
                expression.mark(&#39;I&#39;);

                expression.name(Expression.RuleType.IntegralConstMultiply);

                return expression;
            },
            MultiplyIntegralofFx: function () {
                var c = Expression.variable(&#39;#C&#39;);
                c.mark(&#39;C&#39;);
                var a = Expression.anything();
                a.mark(&#39;A&#39;);
                var I = Expression.integral(a, &#39;x&#39;);
                I.mark(&#39;I&#39;);
                var expression = Expression.multiplication(c, I);

                expression.name(Expression.RuleType.MultiplyIntegralofFx);

                return expression;
            },
            IntegralConst: function () {
                var c = Expression.anything();
                c.mark(&#39;C&#39;);
                c.dependency(&#39;parent&#39;, &#39;respectTo&#39;, Expression.Dependency.IntegralConst);

                var dx = Expression.variable(&#39;x&#39;);
                dx.mark(&#39;dx&#39;);
                var expression = Expression.integral(c, dx);
                expression.mark(&#39;I&#39;);
                expression.name(Expression.RuleType.IntegralConst);
                return expression;
            },
            AxPlusC: function () {
                var a = Expression.anything(&#39;A&#39;);
                a.mark(&#39;A&#39;);
                var x = Expression.variable(&#39;x&#39;);
                x.mark(&#39;x&#39;);
                var c = Expression.variable(&#39;#C&#39;);
                c.mark(&#39;C&#39;);

                var expression = Expression.addition(Expression.multiplication(a, x), c);

                expression.name(Expression.RuleType.AxPlusC);

                return expression;
            },
            Power: function () {
                var n = Expression.variable(&#39;n&#39;);
                n.mark(&#39;n&#39;);
                var x = Expression.variable(&#39;x&#39;);
                x.mark(&#39;x&#39;);
                var power = Expression.power(x, n);

                var expression = Expression.integral(power, &#39;x&#39;);
                expression.mark(&#39;I&#39;);

                expression.name(Expression.RuleType.Power);

                return expression
            },
            PowerIntegrate: function () {
                var n = Expression.variable(&#39;n&#39;);
                n.mark(&#39;n_pre&#39;);
                var n2 = Expression.variable(&#39;n&#39;);
                n2.mark(&#39;n_post&#39;);
                var x = Expression.variable(&#39;x&#39;);
                x.mark(&#39;x&#39;);
                var c = Expression.variable(&#39;C&#39;);
                c.mark(&#39;C&#39;);
                var exp = Expression.addition(Expression.multiplication(
                                Expression.fraction(
                                    Expression.variable(1),
                                    Expression.addition(
                                        n,
                                        Expression.variable(1)
                                    )
                                ),
                Expression.power(
                    x,
                    Expression.addition(n2, Expression.variable(1)))), c);

                exp.name(Expression.RuleType.PowerIntegrate);

                return exp;
            },
            IntegrationAddition: function () {
                var func = Expression.func(&#39;f&#39;, &#39;x&#39;);
                func.mark(&#39;f&#39;);
                var addition = Expression.addition(func);
                addition.mark(&#39;A&#39;);
                addition.repeat = true;
                var dx = Expression.variable(&#39;x&#39;);
                dx.mark(&#39;dx&#39;);
                var integral = Expression.integral(addition, dx);
                integral.mark(&#39;I&#39;);
                integral.name(Expression.RuleType.IntegrationAddition);
                return integral;
            },
            AdditionIntegral: function () {
                var func = Expression.func(&#39;f&#39;, &#39;x&#39;);
                func.mark(&#39;f&#39;);
                var dx = Expression.variable(&#39;x&#39;);
                dx.mark(&#39;dx&#39;);
                var integral = Expression.integral(func, dx);
                integral.mark(&#39;I&#39;);
                var addition = Expression.addition(integral);
                addition.repeat = true;
                addition.mark(&#39;A&#39;);
                addition.name(Expression.RuleType.AdditionIntegral);
                return addition;
            },
            IntegrationByParts: function () {
                var dv = Expression.variable(&#39;v&#39;);
                dv.mark(&#39;dv&#39;);
                var du = Expression.variable(&#39;u&#39;);
                du.mark(&#39;du&#39;);
                var Fx = Expression.func(&#39;f&#39;, du);
                var integral = Expression.integral(Fx, dv);
                integral.name(Expression.RuleType.IntegrationByParts);
                return integral;
            },
            IntegrationByPartsComplete: function () {
                var u1 = Expression.variable(&#39;u&#39;);
                u1.mark(&#39;u_1&#39;);
                var f = Expression.func(&#39;f&#39;, u1);

                var v1 = Expression.variable(&#39;v&#39;);
                v1.mark(&#39;v_1&#39;);
                var g = Expression.func(&#39;g&#39;, v1);

                var mul = Expression.multiplication(f, g);

                var v2 = Expression.variable(&#39;v&#39;);
                v2.mark(&#39;v_2&#39;);
                var g2 = Expression.func(&#39;g&#39;, v2);

                var du = Expression.variable(&#39;u&#39;);
                du.mark(&#39;u_2&#39;);
                var integral = Expression.integral(g2, du);

                var subtraction = Expression.subtraction(mul, integral);

                subtraction.name(Expression.RuleType.IntegrationByPartsComplete);

                return subtraction;
            },
            Fudx: function () {
                var u = Expression.variable(&#39;u&#39;);
                u.mark(&#39;u&#39;);

                var dx = Expression.variable(&#39;x&#39;);
                dx.mark(&#39;dx&#39;);

                var fu = Expression.func(&#39;f&#39;, u);

                var integral = Expression.integral(fu, dx);
                integral.mark(&#39;I&#39;);

                integral.name(Expression.RuleType.Fudx);

                return integral;
            },
            FuOveruprimedx: function () {
                var du3 = Expression.variable(&#39;u&#39;);
                du3.mark(&#39;du3&#39;);

                var FuPrime = Expression.dirivitive(&#39;f&#39;, 1, du3);

                var du2 = Expression.variable(&#39;u&#39;);
                du2.mark(&#39;du2&#39;);

                var Fu = Expression.func(&#39;f&#39;, du2);

                var du = Expression.variable(&#39;u&#39;);
                du.mark(&#39;du&#39;);

                var fraction = Expression.fraction(Fu, FuPrime);

                var integral = Expression.integral(fraction, du);
                integral.name(Expression.RuleType.FuOveruprimedx);
                return integral;
            },
            OneOverX: function () {

                var x = Expression.variable(&#39;x&#39;);
                x.mark(&#39;x&#39;);

                var one = Expression.variable(&#39;1&#39;);

                var fraction = Expression.fraction(one, x);

                var dx = Expression.variable(&#39;x&#39;);

                var integral = Expression.integral(fraction, dx);

                integral.name(Expression.RuleType.OneOverX);

                return integral;
            },
            NaturalLogAbsX: function () {

                var x = Expression.variable(&#39;x&#39;);
                x.mark(&#39;x&#39;);

                var abs = Expression.abs(x);

                var ln = Expression.ln(abs);

                var c = Expression.variable(&#39;c&#39;);

                var addition = Expression.addition(ln, c);

                addition.name(Expression.RuleType.NaturalLogAbsX);

                return addition;
            },
            GeneralFormula8A: function () {
                var a = Expression.variable(&#39;a&#39;);
                a.mark(&#39;a&#39;);

                var x = Expression.variable(&#39;x&#39;);
                x.mark(&#39;x&#39;);

                var x2 = Expression.power(x, 2);

                var a2 = Expression.power(a, 2);

                var denominator = Expression.addition(x2, a2);

                var one = Expression.variable(&#39;1&#39;);

                var f = Expression.fraction(one, denominator);

                var dx = Expression.variable(&#39;x&#39;);

                var integral = Expression.integral(f, dx);
                integral.name(Expression.RuleType.GeneralFormula8A);


                return integral;
            },
            GeneralFormula8B: function () {

                var xtan = Expression.variable(&#39;x&#39;);
                xtan.mark(&#39;x&#39;);

                var atan = Expression.variable(&#39;a&#39;);
                atan.mark(&#39;a_tan&#39;);

                var tanexp = Expression.fraction(xtan, atan);

                var tanInv = Expression.tan(tanexp, -1);

                var denominator = Expression.variable(&#39;a&#39;);
                denominator.mark(&#39;a&#39;);

                var numerator = Expression.variable(&#39;1&#39;);

                var fraction = Expression.fraction(numerator, denominator);

                var c = Expression.variable(&#39;c&#39;);

                var f = Expression.multiplication(fraction, tanInv);

                var addition = Expression.addition(f, c);
                addition.name(Expression.RuleType.GeneralFormula8B);

                return addition;
            },
<span id='MEPH-math-Expression-method-GeneralFormula9A'>            /**
</span>             * http://myhandbook.info/form_integ.html
             * General Formula 8 a
             * @return {MEPH.math.Expression}
             **/
            GeneralFormula9A: function () {
                var a = Expression.variable(&#39;a&#39;);
                a.mark(&#39;a&#39;);

                var x = Expression.variable(&#39;x&#39;);
                x.mark(&#39;x&#39;);

                var a2 = Expression.power(a, 2);
                var x2 = Expression.power(x, 2);

                var denominator = Expression.subtraction(x2, a2);

                var numerator = Expression.variable(&#39;1&#39;);
                var dx = Expression.variable(&#39;x&#39;);
                var f = Expression.fraction(numerator, denominator);

                var integral = Expression.integral(f, dx);
                integral.name(Expression.RuleType.GeneralFormula9A);

                return integral;
            },
<span id='MEPH-math-Expression-method-GeneralFormula9B'>            /**
</span>             * http://myhandbook.info/form_integ.html
             * General Formula 8 b
             * @return {MEPH.math.Expression}
             **/
            GeneralFormula9B: function () {
                var a2 = Expression.variable(&#39;a&#39;);
                a2.mark(&#39;a2&#39;);

                var x2 = Expression.variable(&#39;x&#39;);
                x2.mark(&#39;x2&#39;);

                var denominator = Expression.addition(x2, a2);

                var a1 = Expression.variable(&#39;a&#39;);
                a1.mark(&#39;a1&#39;);

                var x1 = Expression.variable(&#39;x&#39;);
                x1.mark(&#39;x1&#39;);

                var numerator = Expression.subtraction(x1, a1);
                var frac = Expression.fraction(numerator, denominator);

                var abs = Expression.abs(frac);

                var ln = Expression.ln(abs);

                var two = Expression.variable(&#39;2&#39;);

                var a3 = Expression.variable(&#39;a&#39;);
                a3.mark(&#39;a3&#39;);
                var denom = Expression.multiplication(two, a3);

                var num = Expression.variable(&#39;1&#39;);

                var fraction = Expression.fraction(num, denom);

                var f = Expression.multiplication(fraction, ln);

                var c = Expression.variable(&#39;c&#39;);

                var addition = Expression.addition(f, c);

                addition.name(Expression.RuleType.GeneralFormula9B);

                return addition;
            },
<span id='MEPH-math-Expression-method-TrigonometricFormula10A'>            /**
</span>             * http://myhandbook.info/form_integ.html
             * Trigonometric Formula 10 a
             * @return {MEPH.math.Expression}
             **/
            TrigonometricFormula10A: function () {
                var dx = Expression.variable(&#39;x&#39;);
                dx.mark(&#39;dx&#39;);

                var x = Expression.variable(&#39;x&#39;);

                x.mark(&#39;x&#39;);

                var sin = Expression.sin(x);

                var integral = Expression.integral(sin, dx);

                integral.name(Expression.RuleType.TrigonometricFormula10A);

                return integral;
            },
<span id='MEPH-math-Expression-method-TrigonometricFormula10B'>            /**
</span>             * http://myhandbook.info/form_integ.html
             * Trigonometric Formula 10 b
             * @return {MEPH.math.Expression}
             **/
            TrigonometricFormula10B: function () {
                var c = Expression.variable(&#39;c&#39;);

                var x = Expression.variable(&#39;x&#39;);
                x.mark(&#39;x&#39;);

                var cosine = Expression.cos(x);

                var neg1 = Expression.neg(cosine);


                var addition = Expression.addition(neg1, c);

                addition.name(Expression.RuleType.TrigonometricFormula10B);

                return addition;
            },
<span id='MEPH-math-Expression-method-TrigonometricFormula11A'>            /**
</span>             * http://myhandbook.info/form_integ.html
             * Trigonometric Formula 10 a
             * @return {MEPH.math.Expression}
             **/
            TrigonometricFormula11A: function () {
                var dx = Expression.variable(&#39;x&#39;);
                dx.mark(&#39;dx&#39;);

                var x = Expression.variable(&#39;x&#39;);

                x.mark(&#39;x&#39;);

                var cos = Expression.cos(x);

                var integral = Expression.integral(cos, dx);

                integral.name(Expression.RuleType.TrigonometricFormula11A);

                return integral;
            },
<span id='MEPH-math-Expression-method-TrigonometricFormula11B'>            /**
</span>             * http://myhandbook.info/form_integ.html
             * Trigonometric Formula 10 b
             * @return {MEPH.math.Expression}
             **/
            TrigonometricFormula11B: function () {
                var c = Expression.variable(&#39;c&#39;);

                var x = Expression.variable(&#39;x&#39;);
                x.mark(&#39;x&#39;);

                var sin = Expression.sin(x);

                var addition = Expression.addition(sin, c);

                addition.name(Expression.RuleType.TrigonometricFormula11B);

                return addition;
            }
        },
        matchRule: function (expression, rule, markRule) {
            var res = expression.match(rule, markRule || false);
            if (res) {
                expression.name(rule.name());
            }
            return res;
        },
        getMatch: function (expression) {
            return ExpressionMatch.getMatch(expression);
        },
        integrate: function (expression) {
            return ExpressionMatch.integrate(expression);
        },
        anything: function (v) {
            var expression = new Expression();
            expression.anything = v || null;
            expression.setExp(Expression.type.anything);
            return expression;
        },
<span id='MEPH-math-Expression-method-requiresParenthesis'>        /**
</span>         * When printing an expression, sub expressions of certain types should be wrapped in parenthesis,
         * for readability purposes.
         * @param {String} type
         **/
        requiresParenthesis: function (type) {
            switch (type) {
                case Expression.type.subtraction:
                case Expression.type.division:
                case Expression.type.multiplication:
                case Expression.type.addition:
                    return true;
                default: return false;
            }
        },
        power: function (base, power) {
            var expression = new Expression();
            expression.setExp(Expression.type.power);
            expression.addPart(Expression.function.base, base);
            expression.addPart(Expression.function.power, power);
            return expression;
        },
        plusminus: function (a, b) {
            var expression = new Expression();
            expression.setExp(Expression.type.plusminus);
            expression.addPart(Expression.function.input, a);
            expression.addPart(Expression.function.input, b);
            return expression
        },
        variable: function (variable) {
            var expression = new Expression();
            expression.setExp(Expression.type.variable, variable);
            return expression;
        },
        limit: function (exp, a, b) {
            var expression = new Expression();
            expression.setExp(Expression.type.limit);
            expression.addPart(Expression.function.expression, exp);
            expression.addPart(Expression.function.start, a);
            expression.addPart(Expression.function.end, b);
            return expression;
        },
<span id='MEPH-math-Expression-method-addition'>        /**
</span>         * Expresses an addition function, a + b + c + ... + n
         **/
        addition: function (a, b) {
            return Expression.arithmetic.apply(null, [Expression.type.addition].concat(MEPHArray.convert(arguments)));
        },
<span id='MEPH-math-Expression-method-subtraction'>        /**
</span>         * Expresses an addition function, a - b - c - ... - n
         **/
        subtraction: function (a, b) {
            return Expression.arithmetic.apply(null, [Expression.type.subtraction].concat(MEPHArray.convert(arguments)));
        },
<span id='MEPH-math-Expression-method-multiplication'>        /**
</span>         * Expresses an multiplication function, a * b * c * ... * n
         **/
        multiplication: function (a, b) {
            return Expression.arithmetic.apply(null, [Expression.type.multiplication].concat(MEPHArray.convert(arguments)));
        },
<span id='MEPH-math-Expression-method-division'>        /**
</span>         * Expresses an multiplication function, a * b * c * ... * n
         **/
        division: function (a, b) {
            return Expression.arithmetic.apply(null, [Expression.type.division].concat(MEPHArray.convert(arguments)));
        },
<span id='MEPH-math-Expression-method-fraction'>        /**
</span>         * Expresses a fraction
         **/
        fraction: function (numerator, denominator) {
            var expression = new Expression();
            expression.setExp(Expression.type.fraction);
            expression.addPart(Expression.function.numerator, numerator)
            MEPHArray.convert(arguments).subset(1).foreach(function (x) {
                expression.addPart(Expression.function.denominator, x);
            });
            return expression;
        },
        ln: function (x) {
            var expression = new Expression();
            expression.setExp(Expression.type.ln);
            expression.addPart(Expression.function.input, x);
            return expression;
        },
        abs: function (x) {
            var expression = new Expression();
            expression.setExp(Expression.type.abs);
            expression.addPart(Expression.function.input, x);
            return expression;
        },
        neg: function () {
            var expression = new Expression();
            expression.setExp(Expression.type.negative);
            MEPHArray.convert(arguments).foreach(function (x) {
                expression.addPart(Expression.function.input, x);
            });
            return expression;
        },
<span id='MEPH-math-Expression-method-mod'>        /**
</span>         * Expresses a modulo function
         **/
        mod: function (a, b) {
            var expression = new Expression();
            expression.setExp(Expression.type.modulo);
            expression.addPart(Expression.function.input, a)

            expression.addPart(Expression.function.input, b)
            return expression;
        },
<span id='MEPH-math-Expression-method-arithmetic'>        /**
</span>         * Expresses an arithemetic like function, a - b - c - ... - n
         **/
        arithmetic: function (type, a, b) {
            var expression = new Expression();
            expression.setExp(type);
            MEPHArray.convert(arguments).subset(1).foreach(function (x) {
                expression.addPart(Expression.function.input, x);
            });
            return expression;
        },
<span id='MEPH-math-Expression-method-cos'>        /**
</span>         * Expresses cos
         * @param {MEPH.math.Expression} exp
         * @param {Number} power
         **/
        cos: function (exp, power) {
            return Expression.trigonometric(Expression.type.cos, exp, power);
        },
<span id='MEPH-math-Expression-method-tan'>        /**
</span>         * Expresses tan
         * @param {MEPH.math.Expression} exp
         * @param {Number} power
         **/
        tan: function (exp, power) {
            return Expression.trigonometric(Expression.type.tan, exp, power);
        },
<span id='MEPH-math-Expression-method-sin'>        /**
</span>         * Expresses sin
         * @param {MEPH.math.Expression} exp
         * @param {Number} power
         **/
        sin: function (exp, power) {
            return Expression.trigonometric(Expression.type.sin, exp, power);
        },
<span id='MEPH-math-Expression-method-csc'>        /**
</span>         * Expresses csc
         * @param {MEPH.math.Expression} exp
         * @param {Number} power
         **/
        csc: function (exp, power) {
            return Expression.trigonometric(Expression.type.csc, exp, power);
        },
<span id='MEPH-math-Expression-method-sec'>        /**
</span>         * Expresses sec
         * @param {MEPH.math.Expression} exp
         * @param {Number} power
         **/
        sec: function (exp, power) {
            return Expression.trigonometric(Expression.type.sec, exp, power);
        },
<span id='MEPH-math-Expression-method-cot'>        /**
</span>         * Expresses cot
         * @param {MEPH.math.Expression} exp
         * @param {Number} power
         **/
        cot: function (exp, power) {
            return Expression.trigonometric(Expression.type.cot, exp, power);
        },
<span id='MEPH-math-Expression-method-trigonometric'>        /**
</span>         * Expresses a trigonemtric function like, cos, sin and tan
         * @param {String} type
         * @param {MEPH.math.Expression} exp
         * @param {Number} power
         **/
        trigonometric: function (type, exp, power) {
            var expression = new Expression();
            expression.setExp(type);
            expression.addPart(Expression.function.input, exp);
            if (power !== undefined) {
                expression.addPart(Expression.function.power, power);
            }
            return expression;

        },
        func: function (func) {
            var expression = new Expression();
            expression.setExp(Expression.type.func);
            expression.addPart(Expression.function.name, MEPHArray.convert(arguments).first());
            MEPHArray.convert(arguments).subset(1).foreach(function (x) {
                expression.addPart(Expression.function.input, x);
            });
            return expression;
        },
        dirivitive: function (func, dir) {
            var expression = new Expression();
            expression.setExp(Expression.type.dirivitive);
            expression.addPart(Expression.function.name, MEPHArray.convert(arguments).first());
            expression.addPart(Expression.function.dirivitive, dir);
            MEPHArray.convert(arguments).subset(2).foreach(function (x) {
                expression.addPart(Expression.function.input, x);
            });
            return expression;
        },
        theta: function () {
            var expression = new Expression();
            expression.setExp(Expression.type.theta);
            return expression;
        },
<span id='MEPH-math-Expression-method-integral'>        /**
</span>         * Expresses an integral
         **/
        integral: function (exp, dx, a, b) {
            var expression = new Expression();
            expression.setExp(Expression.type.integral);
            expression.addPart(Expression.function.input, exp);
            if (a)
                expression.addPart(Expression.function.start, a);
            if (b)
                expression.addPart(Expression.function.end, b);
            if (dx)
                expression.addPart(Expression.function.respectTo, dx);
            return expression;
        }
    },
    properties: {
        expression: null,
        parts: null,
        type: null,
        dependencies: null,
        _mark: null,
        _parent: null,
        repeat: false,
        _name: null
    },
<span id='MEPH-math-Expression-method-getRepeatParts'>    /**
</span>     * @private
     * If the expession is repeating, its repeating parts are returned in an array.
     * @returns {Array}
     **/
    getRepeatParts: function () {
        var me = this;
        if (me.repeat) {
            return me.getParts();
        }
        return [];
    },
    copy: function () {
        var me = this;
        var expression = new Expression();
        expression.type = me.type;
        expression.mark(me.mark());
        expression.name(me.name());
        expression.repeat = me.repeat;
        expression.parts = me.getParts().select(function (x) {
            var copy = x.val.copy ? x.val.copy() : x.val;
            if (x.val.copy) {
                copy.parent(expression);
            }
            return { type: x.type, val: copy };
        });
        expression.expression = me.expression;
        expression.dependencies = me.getDependencies().select();
        return expression;
    },
    mark: function (val) {
        var me = this;
        if (val !== undefined)
            me._mark = val;
        return me._mark;
    },
    name: function (val) {
        var me = this;
        if (val !== undefined) {
            me._name = val;
        }
        return me._name;
    },
    setExp: function (type, val) {
        var me = this;
        me.type = type;
        if (val !== undefined) {
            me.parts.push({ type: type, val: val });
        }
    },
    clearParts: function () {
        var me = this;
        return me.parts.clear();
    },
<span id='MEPH-math-Expression-method-setParts'>    /**
</span>     * Set the parts of the expression with the same type.
     * @param {Array} parts
     * @param {String} type
     */
    setParts: function (parts, type) {
        var me = this;
        me.clearParts();
        parts.foreach(function (val) {
            me.addPart(type, val);
        });
    },
    getMark: function (mark) {
        var me = this;
        return me.getMarks()[mark];
    },
    setMark: function (mark, val) {
        var me = this;
        var mark = me.getMark(mark);
        debugger
        mark.parts.removeWhere();
    },
    getMarks: function () {
        var me = this,
            marks = {};

        if (me.mark()) {
            marks[me.mark()] = me;
        }

        me.parts.foreach(function (part) {
            if (part &amp;&amp; part.val &amp;&amp; part.val.getMarks) {
                var submarks = part.val.getMarks();
                for (var i in submarks) {
                    if (submarks[i])
                        marks[i] = submarks[i];
                }
            }
        });
        return marks;
    },
<span id='MEPH-math-Expression-method-respects'>    /**
</span>     * Gets the list of variables and consts in the expression.
     * @return {Array}
     **/
    respects: function () {
        var me = this;
        var respects = me.getParts().select(function (x) {
            if (x.val) {
                if (x.val instanceof Expression) {
                    return x.val.respects();
                }
                else {
                    if (isNaN(parseFloat(x.val))) {
                        return x.val;
                    }
                    else return null;
                }
            }
            else {
                return null;
            }
        }).concatFluent(function (x) {
            if (x) {
                return Array.isArray(x) ? x : [x];
            }
            return [];
        }).unique();

        return respects;
    },
    addPart: function (type, val) {
        var me = this;
        if (val.parent) {
            val.parent(me);
        }
        me.parts.push({ type: type, val: val });
    },
    parent: function (parent) {
        var me = this;

        if (parent) {
            me._parent = parent;
        }

        return me._parent;
    },
<span id='MEPH-math-Expression-method-dependency'>    /**
</span>     * Adds a dependency between itself and another expression relative to it.
     * @param {String} offset
     * @param {String} part
     * @param {Function} ruleFunc
     */
    dependency: function (offset, part, ruleFunc) {
        var me = this;
        me.dependencies.push({ offset: offset, part: part, ruleFunction: ruleFunc });
    },
<span id='MEPH-math-Expression-method-getDependencies'>    /**
</span>     * Gets dependencies
     * @return {Array}
     **/
    getDependencies: function () {
        var me = this;
        return me.dependencies;
    },
    dependenciesAreRespected: function (expession) {
        var me = this;

        return me.getDependencies().all(function (d) {
            var offset;
            switch (d.offset) {
                case &#39;parent&#39;:
                    offset = expession.parent();
                    break
                default:
                    throw new Error(&#39;not handled offset&#39;);
            }
            if (!offset) {
                throw new Error(&#39;no offset found&#39;);
            }
            var part = offset.part(d.part);
            return d.ruleFunction(expession, part);
        });
    },
<span id='MEPH-math-Expression-method-latex'>    /**
</span>     * Converts expressions in to latex format.s
     * @return {String}
     **/
    latex: function () {
        var me = this,
            result;
        switch (me.type) {
            case Expression.type.variable:
                return me.parts.first().val;
            case Expression.type.integral:
                //\int_a^b \! f(x) \, \mathrm{d}x.
                var start = me.partLatex(Expression.function.start);
                var end = me.partLatex(Expression.function.end);
                var middle = &#39;&#39;;
                if (start &amp;&amp; end) {
                    middle = start + &#39;^&#39; + end;
                }
                result =
                    &#39;\\int_&#39; +
                    middle + &#39; &#39; +
                &#39;\\! &#39; +
                me.partLatex(Expression.function.input) + &#39; &#39; +
                &#39;\\,&#39; + &#39; &#39; +
                &#39;\\mathrm{d}&#39; +
                me.partLatex(Expression.function.respectTo) + &#39;&#39;
                return result;
            case Expression.type.addition:
                return me.parts.select(function (x) {
                    return x.val.latex();
                }).join(&#39; + &#39;);
                break;
            case Expression.type.subtraction:
                return me.parts.select(function (x) {
                    return x.val.latex();
                }).join(&#39; - &#39;);
                break;
            case Expression.type.anything:
                return me.anything || &#39;f(x)&#39;;
            case Expression.type.func:
                return me.partLatex(Expression.function.name) + &#39;(&#39; + me.parts.subset(1).select(function (x) {
                    return x.val &amp;&amp; x.val.latex ? x.val.latex() : x.val;
                }).join(&#39;,&#39;) + &#39;)&#39;;
                break;
            case Expression.type.dirivitive:
                return me.partLatex(Expression.function.name) +
                    [].interpolate(0, parseInt(me.parts.nth(2).val), function (x) {
                        return &quot;&#39;&quot;;
                    }).join(&#39;&#39;) +
                    &#39;(&#39; + me.parts.subset(2).select(function (x) {
                        return x.val &amp;&amp; x.val.latex ? x.val.latex() : x.val;
                    }).join(&#39;,&#39;) + &#39;)&#39;;
                break;
            case Expression.type.multiplication:
                if (me.parts.unique(function (x) { return x.val.latex(); }).length !== me.parts.length ||
                    me.parts.where(function (x) { return parseFloat(x.val.latex()); }).length !== me.parts.length || x.val.latex() === &#39;0&#39;) {
                    return me.parts.orderBy(me.orderParts.bind(me)).select(function (x, index) {
                        return x.val.latex();
                    }).join(&#39;&#39;);
                }
                else
                    return me.parts.orderBy(me.orderParts.bind(me)).select(function (x, index) {
                        return x.val.latex();
                    }).join(&#39; * &#39;);
                break;
            case Expression.type.modulo:
                return me.latexPart(me.parts.nth(1)) +
                    &#39; \\bmod &#39; +
                    me.latexPart(me.parts.nth(2));
                break;
            case Expression.type.negative:
                return &#39;-&#39; + me.parts.orderBy(me.orderParts.bind(me)).select(function (x, index) {
                    return x.val &amp;&amp; x.val.latex ? x.val.latex() : x.val;
                }).join(&#39;&#39;);;
            case Expression.type.limit:
                var exp = me.partLatex(Expression.function.expression);
                var a = me.partLatex(Expression.function.start);
                var b = me.partLatex(Expression.function.end);
                return &#39;\\lim_{&#39; + a + &#39; \\to &#39; + b + &#39;} &#39; + exp
                break;
            case Expression.type.division:
                return me.parts.select(function (x) {
                    return x.val.latex();
                }).join(&#39; / &#39;);
                break;
            case Expression.type.ln:
                var start = &#39;\\ln &#39;;
                if (me.parts.length &gt; 1) {
                    start += &#39;(&#39;;
                }
                var val = me.parts.first().val;
                if (val.latex) {
                    start += val.latex();
                }
                else {
                    start += val;
                }
                if (me.parts.length &gt; 1) {
                    start += &#39;)&#39;;
                }
                return start;
            case Expression.type.abs:
                var start = &#39;|&#39;;

                var val = me.parts.select(function (x) {
                    return me.latexPart(x);
                }).join(&#39;&#39;);
                start += val;
                start += &#39;|&#39;;
                return start;
            case Expression.type.fraction:
                if (me.parts.length === 2) {
                    return &#39;\\frac{&#39; + me.partLatex(Expression.function.numerator) +
                        &#39;}{&#39; + me.partLatex(Expression.function.denominator) + &#39;}&#39;;
                }
                else {
                    var start = &#39;\\begin{equation}&#39;;
                    var end = &#39; \\end{equation}&#39;;
                    me.parts.subset(0, me.parts.length - 1).foreach(function (part) {
                        start += &#39; \\cfrac{&#39; + me.latexPart(part) + &#39;}{&#39;;

                        end = &#39;}&#39; + end;
                    });
                    return start + me.latexPart(me.parts.last()) + end;
                }
                break;
            case Expression.type.plusminus:
                var a = me.parts.first(function (x) { return x.type === Expression.function.input; });
                var b = me.parts.second(function (x) { return x.type === Expression.function.input; });

                return me.latexPart(a) + &#39; \\pm &#39; + me.latexPart(b);
                break;
            case Expression.type.theta:
                return &#39;\\theta&#39;;
            case Expression.type.tan:
            case Expression.type.sin:
            case Expression.type.cos:
            case Expression.type.sec:
            case Expression.type.cot:
            case Expression.type.csc:
                var power = me.partLatex(Expression.function.power);
                if (power) {
                    power = &#39;^&#39; + power;
                }
                else { power = &#39;&#39; }
                return &#39;\\&#39; + me.type + power + &#39; (&#39; + me.partLatex(Expression.function.input) + &#39;)&#39;;
            case Expression.type.power:
                return me.partLatex(Expression.function.base) + &#39;^{&#39; + me.partLatex(Expression.function.power) + &#39;}&#39;;
                break;
            default:
                throw new Error(&#39;unhandled : &#39; + me.type);
        }
    },
    latexPart: function (start) {
        if (start &amp;&amp; start.val) {
            if (start.val.latex) {
                start = start.val.latex();
            }
            else {
                start = start.val;
            }
        }
        return start || &#39;&#39;;
    },
    partLatex: function (type) {
        var me = this;
        var start = me.part(type);
        return me.latexPart(start);
    },
    part: function (type) {
        var me = this;
        return me.parts.first(function (x) { return x.type === type; });
    },
<span id='MEPH-math-Expression-method-swap'>    /**
</span>     * Swaps the part from the mark.
     ***/
    swap: function (mark, exp) {
        var me = this,
            marks = me.getMarks();
        var parts = me.getParts()
        if (marks[mark]) {
            var parent = marks[mark].parent();
            var part = parent.remove(marks[mark]).first();
            exp.mark(mark);
            parent.addPart(part.type, exp);
        }

    },
<span id='MEPH-math-Expression-method-orderParts'>    /**
</span>     * @private
     */
    orderParts: function (a, b) {
        var order = {
            variable: 0,
            ln: 8,
            integral: 10,
            addition: 5,
            power: 5,
            limit: 5,
            fraction: 3,
            sin: 5,
            cos: 5,
            tan: 5,
            csc: 5,
            cot: 5,
            sec: 5,
            tan: 5,
            func: 5,
            mod: 5,
            modulo: 5,
            theta: 5,
            subtraction: 5,
            plusminus: 5,
            multiplication: 5,
            division: 5,
            anything: 5
        }

        return (a.val &amp;&amp; a.val.type ? order[a.val.type] || 0 : 0) - (b.val &amp;&amp; b.val.type ? order[b.val.type] || 0 : 0);
    },
<span id='MEPH-math-Expression-method-remove'>    /**
</span>     * Removes the part.
     * @param {MEPH.math.Expression} part
     * @returns {Array} removed parts.
     **/
    remove: function (part) {
        var me = this;
        return me.getParts().removeWhere(function (x) { return x.val === part; });
    },
    partVal: function (type) {
        var me = this;
        var part = me.part(type);
        if (part) {
            return part.val;
        }
        return null;
    },
    getParts: function () {
        var me = this;
        return me.parts;
    },
    initialize: function (type) {
        var me = this;
        me.expression = {
        };
        me.dependencies = [];
        me.parts = [];
    },
<span id='MEPH-math-Expression-method-match'>    /**
</span>     * Matches an expression to a rule.
     * @param {MEPH.math.Expression} rule
     * @return {Boolean}
     **/
    match: function (rule, markRule) {
        var me = this;
        if (me.type === rule.type) {
            var meParts = me.getParts().select();
            var ruleParts = rule.getParts().select();

            var matchParts = function (ruleParts, x) {
                var first = ruleParts.first(function (y) {
                    if (y.type !== x.type) {
                        return false;
                    }
                    if (y.val &amp;&amp; x.val &amp;&amp; y.val.equals &amp;&amp; x.val.equals) {
                        return x.val.match(y.val, markRule);
                    }
                    else if (y.val &amp;&amp; !x.val || !y.val &amp;&amp; x.val) {
                        return false;
                    }
                    else {
                        return true
                    }
                });
                if (first) {
                    ruleParts.removeFirstWhere(function (t) { return t === first; });
                    return first;
                }
                else return false;
            };
            if (rule.repeat) {
                var repeatedparts = [].interpolate(0, me.getParts().length, function () {
                    return rule.parts.first();
                });
                meParts.foreach(matchParts.bind(me, repeatedparts));
                if (repeatedparts.length === 0) {
                    if (markRule) {
                        me.mark(rule.mark());
                    }
                    me.repeat = rule.repeat;

                    return true;
                }
                return false;
            }
            else if (rule.part(Expression.type.anything)) {

                ruleParts = rule.getParts().select().where(function (x) {
                    return x.type === Expression.type.anything;
                });

                meParts.foreach(matchParts.bind(me, ruleParts));
                if (ruleParts.length === 0) {
                    if (markRule) {
                        me.mark(rule.mark());
                    }
                    return true;
                }
                return false;
            }
            else {
                if (meParts.length !== ruleParts.length) {
                    return false;
                }
                meParts.foreach(matchParts.bind(me, ruleParts));
                if (ruleParts.length &gt; 0) {
                    return false;
                }
                if (markRule) {
                    me.mark(rule.mark());
                }

                return true;
            }
        }
        else if (rule.type === Expression.type.anything &amp;&amp; rule.dependenciesAreRespected(me)) {
            if (markRule) {
                me.mark(rule.mark());
            }
            return true;
        }

        return false;
    },
<span id='MEPH-math-Expression-method-equals'>    /**
</span>     * Returns true if the equation are equal
     * @param {Object} options
     * @param {Boolean} options.formEquals
     */
    equals: function (expression, options) {
        var me = this;
        options = options || { formEquals: true };

        if (me.type === expression.type) {
            var meparts = me.getParts().select();
            var expparts = expression.getParts().select(function (x) { return x; });
            if (meparts.length !== expparts.length) return false;
            meparts.foreach(function (x) {
                var first = expparts.first(function (y) {
                    if (y.type !== x.type) {
                        return false;
                    }
                    if (y.val &amp;&amp; x.val &amp;&amp; y.val.equals &amp;&amp; x.val.equals) {
                        return y.val.equals(x.val);
                    }
                    else if (y.val &amp;&amp; !x.val || !y.val &amp;&amp; x.val) {
                        return false;
                    }
                    else {
                        return true
                    }
                });
                if (first) {
                    expparts.removeWhere(function (t) { return t === first; });
                }
                else return false;
            });
            if (expparts.length &gt; 0) return false;
            return true;
        }
    }
});</pre>
</body>
</html>
