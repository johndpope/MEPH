Ext.data.JsonP.binding({"guide":"<h1 id='binding-section-binding%2C-not-bondage'>Binding, not Bondage</h1>\n<div class='toc'>\n<p><strong>Contents</strong></p>\n<ol>\n<li><a href='#!/guide/binding-section-binding-is-what%3F'>Binding is what?</a></li>\n<li><a href='#!/guide/binding-section-meph-binding'>MEPH Binding</a></li>\n<li><a href='#!/guide/binding-section-views%2C-presenters%2C-controllers-oh-my'>Views, Presenters, Controllers oh my</a></li>\n</ol>\n</div>\n\n<p>A guide abount binding in MEPH.</p>\n\n<h2 id='binding-section-binding-is-what%3F'>Binding is what?</h2>\n\n<p><a href=\"http://en.wikipedia.org/wiki/Data_binding\">Wikipedia</a> describes data binding as a \"process that establishes a connection between the application UI(User Interface) and business logic. ...\". In MEPH this is also the case.</p>\n\n<h2 id='binding-section-meph-binding'>MEPH Binding</h2>\n\n<p>In MEPH, a view can have an associated presenter, controller, model, viewmodel or whatever in any combination that the mind can imagine. To support the single responsibility portion of the <a href=\"http://en.wikipedia.org/wiki/SOLID_(object-oriented_design\">SOLID</a>) principles, MEPH has a particularly unique way of establishing data-binding.</p>\n\n<h3 id='binding-section-example-1'>Example 1</h3>\n\n<p>The simplest situation which can exist is a view which has no presenter/controller/model/etc associated with the instance, and also has no controls within itself.</p>\n\n<ul>\n<li><p>Definitaion of the view in the views.json description.</p>\n\n<pre><code>     {\n         view : 'App.view.View'\n     }\n</code></pre></li>\n<li><p>Definition of App.view.View</p>\n\n<pre><code> MEPH.define('App.view.View', {\n     alias: 'app_view_view',\n     templates: true,\n     extend: 'MEPH.mobile.activity.container.Container',\n     properties: {\n         name: null\n     },\n     afterLoaded: function() {\n         var me= this;\n         me.name = 'MEPH Framework';\n     }\n })\n</code></pre></li>\n<li><p>Template for App.view.View</p>\n\n<pre><code> &lt;div&gt;\n     &lt;span data-bind='\"innerHTML\": \"c$.name\"'&gt;&lt;/span&gt;\n &lt;/div&gt;\n</code></pre></li>\n</ul>\n\n\n<p>That's it. Did you miss it? Here is the breakdown of the pertinent information. In the span there is a <strong>data-bind</strong> attribute which contains a <strong>special string</strong>. The <strong>'\"innerHTML\": \"c$.name\"'</strong> is the binding configuration. In laymen's terms the <strong>innerHTML</strong> property of the span will be bound to the context's/control's <strong>name</strong> property. The current context/control is the  <strong>c$</strong>.</p>\n\n<p>When ever the name property's value changes, the span's <strong>innerHTML</strong> property will be updated to the new value.</p>\n\n<pre><code>    &lt;div&gt;\n        &lt;span data-bind='\"innerHTML\": \"c$.name\"'&gt;&lt;/span&gt;\n    &lt;/div&gt;\n</code></pre>\n\n<p><strong>What about input field's</strong>\nLet's say that the App.view.View was a bit more complex like:</p>\n\n<pre><code>    &lt;div&gt;\n        &lt;span data-bind='\"innerHTML\": \"c$.name\"'&gt;&lt;/span&gt;\n        &lt;input data-bind='\"value\": \"c$.inputfield.value\"'\n                u4mid=\"inputfield\"\n                data-events='\"change\" : \"c$.inputfield.value | c$.value\"' /&gt;\n    &lt;/div&gt;\n</code></pre>\n\n<p>The span tag hasn't changed at all, but there is new input field tag with more attributes attached.</p>\n\n<p><strong>An explanation about each of the input's attributes</strong></p>\n\n<ul>\n<li><strong>u4mid</strong>: This is the id which the App.view.View will provide direct access the input field.</li>\n<li><strong>data-bind</strong>: Just like the span tag, the value property of the input will be set to the value property of the current control's/context's inputfield's value. As mentioned, the c$ in this case is the App.view.View instance. It has a property called inputfield, which is the input field with the attribute <strong>u4mid=\"inputfield\"</strong>.</li>\n<li><strong>data-events</strong>: This describes the event which will trigger the inputfield of c$ to transfer its value to the App.view.View instance's value property.</li>\n</ul>\n\n\n<p>The attribute-property combination, <strong>data-events='\"change\" : \"c$.inputfield.value | c$.value\"'</strong>, has a piece of syntax which hasn't been fully explained yet. That is the pipe, <strong>|</strong>.</p>\n\n<h4 id='binding-section-the-pipe'>The Pipe</h4>\n\n<p>The pipe is a powerful tool in MEPH. It allows developers to call multiple procedures and set multiple properties in all available contexts with ease. In the previous example <strong>\"c$.inputfield.value | c$.value\"</strong>, the inputfield's value will be set on the context's value property automatically.</p>\n\n<p>That's nice, but can it do more. <strong>Yes!</strong>.</p>\n\n<pre><code>        &lt;span data-bind='\"innerHTML\": \"c$.field.value | c$.name | c$.property1 | c$.function1 \"'&gt;&lt;/span&gt;\n</code></pre>\n\n<p><strong>Explanation</strong></p>\n\n<p>When the context's field's value property changes, its value will be set on the context's name property, which will in turn set the context's property1 property which will finally call the context's function1 function and the result of that function will be set on the span's innerHTML property.</p>\n\n<p>There has been a lot of explanation about the context/c$, and that works great when creating a control, but what about binding to a view, presenter, viewmodel, controller, etc.</p>\n\n<h2 id='binding-section-views%2C-presenters%2C-controllers-oh-my'>Views, Presenters, Controllers oh my</h2>\n\n<p>This section is about how to bind to combinations of views, presenters, controllers, and etc.</p>\n\n<h3 id='binding-section-example-2'>Example 2</h3>\n\n<p>At this point, App.view.View will take on a new definition and there will be a few new classes added to the mix. One of the <a href=\"http://en.wikipedia.org/wiki/SOLID_(object-oriented_design\">SOLID</a>) principles, single responsibility principle specifically. Wikipedia states, \"\na class should have only a single responsibility (i.e. only one potential change in the software's specification should be able to affect the specification of the class)\". This gives rise to the need of a controller and a model to separate functionally different areas.</p>\n\n<ul>\n<li><p>Definitaion of the view in the views.json description.</p>\n\n<pre><code>     {\n         view : 'App.view.View',\n         controller: 'App.controller.Controller',\n         model: 'App.model.Model'\n     }\n</code></pre></li>\n<li><p>Definition of App.view.View</p>\n\n<pre><code> MEPH.define('App.view.View', {\n     alias: 'app_view_view',\n     templates: true,\n     extend: 'MEPH.mobile.activity.container.Container',\n     properties: {\n         name: null\n     },\n     afterLoaded: function() {\n         var me= this;\n         me.name = 'MEPH Framework';\n     }\n });\n</code></pre></li>\n<li><p>Template for App.view.View</p>\n\n<pre><code> &lt;div&gt;\n     &lt;span data-bind='\"innerHTML\": \"m$.name\"'&gt;&lt;/span&gt;\n     &lt;input data-bind='\"value\": \"m$.value\"'\n             u4mid=\"namefield\"\n             data-events='\"change\" : \" m$.value\"' /&gt;\n     &lt;input data-bind='\"value\": \"m$.address\"'\n             u4mid=\"addressfield\"\n             data-events='\"change\" : \" m$.address\"' /&gt;\n     &lt;button data-events='\"click\": \"ct$.save\"'&gt;&lt;/button&gt;\n &lt;/div&gt;\n</code></pre></li>\n<li><p>Definition of App.controller.Controller</p>\n\n<pre><code> MEPH.define('App.controller.Controller', {\n     requires: ['MEPH.controller.Controller'],\n     extend: 'MEPH.controller.Controller',\n     properties: {\n         name: null\n     },\n     save: function() {\n         var me= this; \n         me.serviceCaller.call(me.model,....);\n     }\n });\n</code></pre></li>\n<li><p>Definition of App.model.Model</p>\n\n<pre><code> MEPH.define('App.model.Model', {\n     requires: ['MEPH.model.Model'],\n     extends: ['MEPH.model.Model'],\n     properties: {\n         name: null,\n         value: null,\n         address: null\n     },\n     initialize: function () {\n         var me = this;\n         me.callParent.apply(me, arguments);\n     }\n });\n</code></pre></li>\n</ul>\n\n\n<p>With a model, controller and view defined the power of meph binding is now visible for all to see.</p>\n\n<p>To reference models, controllers and etc, MEPH has built in short cuts :</p>\n\n<ul>\n<li><strong>m$</strong>, <strong>model</strong> model, References the model associated with the view</li>\n<li><strong>v$</strong>, <strong>view</strong> view, References the view</li>\n<li><strong>vm$</strong>, <strong>viewmodel</strong> viewmodel, References the view model</li>\n<li><strong>p$</strong>, <strong>presenter</strong> presenter, References the presenter</li>\n<li><strong>ct$</strong>, <strong>controller</strong> controller, References the controller</li>\n<li><strong>c$</strong>, <strong>control</strong> control, Reference the control</li>\n</ul>\n\n\n<p>In <strong>example 2</strong> ,</p>\n\n<ul>\n<li><strong>m$.name</strong>  references the model instance property name.</li>\n<li><strong>m$.value</strong> references the model instance property value.</li>\n<li><strong>m$.address</strong> references the model instance property address.</li>\n<li><strong>ct$.save</strong> references the controller instance function save.</li>\n</ul>\n\n\n<p>When the model's name property changes the innerHTML property of the span will be set to the name property's value. The same pattern applies to the value and adress property of the model. When the value of the namefield input is changed the model's value property will be set, and when the addressfield is changed, its value will be set to the model's address property. Finally when the button is clicked the controller's save function is executed.</p>\n\n<pre><code>    &lt;div&gt;\n        &lt;span data-bind='\"innerHTML\": \"m$.name\"'&gt;&lt;/span&gt;\n        &lt;input data-bind='\"value\": \"m$.value\"'\n                u4mid=\"namefield\"\n                data-events='\"change\" : \" m$.value\"' /&gt;\n        &lt;input data-bind='\"value\": \"m$.address\"'\n                u4mid=\"addressfield\"\n                data-events='\"change\" : \" m$.address\"' /&gt;\n        &lt;button data-events='\"click\": \"ct$.save\"'&gt;&lt;/button&gt;\n    &lt;/div&gt;\n</code></pre>\n\n<p>Here is a practical example of <strong>data-events</strong> in use. This tag will initiate a binding sequence when the described, in this case <strong>click</strong>, event occurrs. In the case of:</p>\n\n<pre><code>    &lt;button data-events='\"click\": \"ct$.save\"'&gt;&lt;/button&gt;\n</code></pre>\n\n<p>The <strong>data-events</strong> tag states that when the button is clicked, the controller will execute its save function.</p>\n","title":"Get my binding on."});